package main

import (
	"fmt"
	"reflect"
	"strings"
	"sync"
)

// ========== Dependency Injection ==========

// Container manages dependencies
type Container struct {
	services map[string]interface{}
	factories map[string]interface{}
	mu       sync.RWMutex
}

// NewContainer creates a dependency container
func NewContainer() *Container {
	return &Container{
		services:  make(map[string]interface{}),
		factories: make(map[string]interface{}),
	}
}

// Register registers a service instance
func (c *Container) Register(name string, service interface{}) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	if _, exists := c.services[name]; exists {
		return fmt.Errorf("service %s already registered", name)
	}

	c.services[name] = service
	return nil
}

// RegisterFactory registers a factory function
func (c *Container) RegisterFactory(name string, factory interface{}) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	if _, exists := c.factories[name]; exists {
		return fmt.Errorf("factory %s already registered", name)
	}

	c.factories[name] = factory
	return nil
}

// Get retrieves a service
func (c *Container) Get(name string) (interface{}, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	if svc, exists := c.services[name]; exists {
		return svc, nil
	}

	if factory, exists := c.factories[name]; exists {
		// Execute factory
		fn := reflect.ValueOf(factory)
		result := fn.Call([]reflect.Value{})

		if len(result) > 1 && !result[1].IsNil() {
			return nil, result[1].Interface().(error)
		}

		return result[0].Interface(), nil
	}

	return nil, fmt.Errorf("service not found: %s", name)
}

// ========== Code Quality Patterns ==========

// LinterConfig represents linter configuration
type LinterConfig struct {
	Enabled []string          // Enabled linters
	Settings map[string]interface{} // Per-linter settings
}

// GetGolangciLintConfig returns typical golangci-lint config
func GetGolangciLintConfig() string {
	return `
# .golangci.yml - golangci-lint configuration

run:
  timeout: 5m
  deadline: 10m

linters:
  enable:
    - deadcode         # Find unused code
    - errcheck         # Check for unchecked errors
    - gosimple         # Suggest code simplification
    - govet            # Report suspicious constructs
    - ineffassign      # Detect unused assignments
    - misspell         # Find misspelled words
    - structcheck      # Find unused struct fields
    - typecheck        # Typecheck during linting
    - unused           # Check for unused code
    - cyclop           # Check cyclomatic complexity
    - gocyclo          # Check cyclomatic complexity
    - gofmt            # Check code formatting
    - goimports        # Check import ordering
    - gosec            # Security issues
    - maligned         # Check alignment
    - prealloc         # Check preallocation
    - unconvert        # Find unnecessary type conversions
    - unparam          # Find unused parameters
    - varcheck         # Find unused variables

linters-settings:
  cyclop:
    max-complexity: 10
  gocyclo:
    min-complexity: 15
  gosec:
    excludes:
      - G404  # Random number generation
  goimports:
    local-prefixes: github.com/example/myapp
  misspell:
    locale: US

issues:
  exclude-rules:
    - linters:
        - errcheck
      text: "Error return value of.*is not checked"
  max-issues-per-linter: 0
  max-same-issues: 0
`
}

// MockGenerator generates mock interfaces
type MockGenerator struct {
	pkgName string
	interfaces []string
}

// NewMockGenerator creates a mock generator
func NewMockGenerator(pkgName string) *MockGenerator {
	return &MockGenerator{
		pkgName:    pkgName,
		interfaces: []string{},
	}
}

// AddInterface adds an interface to generate mocks for
func (mg *MockGenerator) AddInterface(name string) {
	mg.interfaces = append(mg.interfaces, name)
}

// Generate generates mock implementation
func (mg *MockGenerator) Generate() string {
	output := fmt.Sprintf("// Code generated by MockGenerator for package %s\n", mg.pkgName)
	output += "// DO NOT EDIT - This file was automatically generated\n\n"
	output += fmt.Sprintf("package %s\n\n", mg.pkgName)
	output += "import \"github.com/stretchr/testify/mock\"\n\n"

	for _, iface := range mg.interfaces {
		output += fmt.Sprintf("// Mock%s is a mock implementation of %s\n", iface, iface)
		output += fmt.Sprintf("type Mock%s struct {\n", iface)
		output += "	mock.Mock\n"
		output += "}\n\n"
	}

	return output
}

// ========== Go Generate Directive ==========

// GetGoGenerateDirective returns example go:generate directives
func GetGoGenerateDirective() map[string]string {
	return map[string]string{
		"mockgen": `
//go:generate mockgen -destination=mocks/mock_user_service.go -package=mocks . UserService
// This generates mocks for UserService interface
`,

		"stringer": `
//go:generate stringer -type=Status -output=status_string.go
// Generates String() method for Status enum
`,

		"go-bindata": `
//go:generate go-bindata -o=bindata.go -pkg=main ./assets/...
// Embeds assets into binary
`,

		"easyjson": `
//go:generate easyjson -all models.go
// Generates fast JSON marshaling/unmarshaling
`,

		"protoc": `
//go:generate protoc -I=proto --go_out=. user.proto
// Generates Protocol Buffer code
`,

		"sql-migrate": `
//go:generate sql-migrate up -env production
// Runs database migrations
`,
	}
}

// ========== Interface Definitions ==========

// Logger interface for dependency injection
type Logger interface {
	Info(msg string)
	Error(msg string, err error)
	Debug(msg string)
}

// SimpleLogger implements Logger
type SimpleLogger struct{}

func (l *SimpleLogger) Info(msg string) {
	fmt.Println("[INFO]", msg)
}

func (l *SimpleLogger) Error(msg string, err error) {
	fmt.Printf("[ERROR] %s: %v\n", msg, err)
}

func (l *SimpleLogger) Debug(msg string) {
	fmt.Println("[DEBUG]", msg)
}

// Repository interface
type Repository interface {
	Get(id string) (interface{}, error)
	Save(id string, data interface{}) error
}

// UserRepository implements Repository
type UserRepository struct {
	storage map[string]interface{}
	mu      sync.RWMutex
}

// NewUserRepository creates user repository
func NewUserRepository() *UserRepository {
	return &UserRepository{
		storage: make(map[string]interface{}),
	}
}

// Get retrieves a user
func (r *UserRepository) Get(id string) (interface{}, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	if val, exists := r.storage[id]; exists {
		return val, nil
	}

	return nil, fmt.Errorf("user not found: %s", id)
}

// Save stores a user
func (r *UserRepository) Save(id string, data interface{}) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	r.storage[id] = data
	return nil
}

// ========== Code Quality Analysis ==========

// CodeMetrics represents code quality metrics
type CodeMetrics struct {
	TotalLines    int
	CodeLines     int
	CommentLines  int
	BlankLines    int
	Complexity    int
	Duplication   float64 // percentage
}

// AnalyzeCode analyzes code quality
func AnalyzeCode(code string) CodeMetrics {
	lines := strings.Split(code, "\n")
	metrics := CodeMetrics{}

	for _, line := range lines {
		metrics.TotalLines++
		trimmed := strings.TrimSpace(line)

		if trimmed == "" {
			metrics.BlankLines++
		} else if strings.HasPrefix(trimmed, "//") {
			metrics.CommentLines++
		} else {
			metrics.CodeLines++
		}
	}

	return metrics
}

// ========== Testing Patterns ==========

// TestHelper provides testing utilities
type TestHelper struct{}

// AssertEqual checks equality
func (th *TestHelper) AssertEqual(expected, actual interface{}) bool {
	return reflect.DeepEqual(expected, actual)
}

// AssertNil checks for nil
func (th *TestHelper) AssertNil(value interface{}) bool {
	if value == nil {
		return true
	}
	rv := reflect.ValueOf(value)
	return rv.Kind() == reflect.Ptr || rv.Kind() == reflect.Interface && rv.IsNil()
}

// AssertNotNil checks for non-nil
func (th *TestHelper) AssertNotNil(value interface{}) bool {
	if value != nil {
		rv := reflect.ValueOf(value)
		if rv.Kind() == reflect.Ptr || rv.Kind() == reflect.Interface {
			return !rv.IsNil()
		}
		return true
	}
	return false
}

// ========== Linter Rules ==========

// LintRule represents a linting rule
type LintRule struct {
	Name        string
	Description string
	Severity    string // error, warning
	Pattern     string
}

// GetLintRules returns recommended lint rules
func GetLintRules() []LintRule {
	return []LintRule{
		{
			Name:        "unused-variables",
			Description: "Check for unused variable assignments",
			Severity:    "warning",
		},
		{
			Name:        "error-checking",
			Description: "Ensure all errors are checked",
			Severity:    "error",
		},
		{
			Name:        "cyclomatic-complexity",
			Description: "Functions should have low complexity",
			Severity:    "warning",
		},
		{
			Name:        "naming-conventions",
			Description: "Follow Go naming conventions",
			Severity:    "warning",
		},
		{
			Name:        "security-issues",
			Description: "Check for security vulnerabilities",
			Severity:    "error",
		},
		{
			Name:        "code-duplication",
			Description: "Minimize code duplication",
			Severity:    "warning",
		},
	}
}

// ========== Example Service with DI ==========

// UserService uses dependency injection
type UserService struct {
	logger Logger
	repo   Repository
}

// NewUserService creates user service with injected dependencies
func NewUserService(logger Logger, repo Repository) *UserService {
	return &UserService{
		logger: logger,
		repo:   repo,
	}
}

// GetUser retrieves a user
func (us *UserService) GetUser(id string) (interface{}, error) {
	us.logger.Info(fmt.Sprintf("Getting user %s", id))

	user, err := us.repo.Get(id)
	if err != nil {
		us.logger.Error("Failed to get user", err)
		return nil, err
	}

	return user, nil
}

// SaveUser saves a user
func (us *UserService) SaveUser(id string, data interface{}) error {
	us.logger.Info(fmt.Sprintf("Saving user %s", id))

	if err := us.repo.Save(id, data); err != nil {
		us.logger.Error("Failed to save user", err)
		return err
	}

	return nil
}

func main() {}
